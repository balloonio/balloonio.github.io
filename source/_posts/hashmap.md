---
title: Hashmap
date: 2018-11-04 01:28:03
tags:
- algorithm
- hashmap
- data structure
categories:
  - - Algorithms
    - Data Structure
---

# 综述

粗略的说,哈希表是一种读写均为常数级别时间复杂度的数据结构,支持`O(1)`时间添加删除和修改,数据之间无序. 为什么是粗略地说,因为严格来讲,其增删查改的时间复杂度与 key 的大小成正相关,这是由于哈希函数生成哈希值的时间复杂度为`O(size of key)`.  
哈希表的使用场景通常具有以下特点

- 快速增删查改
- 对有序性无要求

# 哈希表的实现

## 哈希函数

哈希函数的目的是作为一个映射,将key对应到一个地址空间上,通常的哈希函数具有如下特点.

- 快速生成哈希值,时间复杂度为`O(size of key)`
- 生成哈希值在一确定区间内,因为需要确切的地址空间范围来存储这些数据
- 生成的哈希值越随机越好,因为哈希值越随机就越与 key 无关,这就使得大量的数据可以不收 key 影响的情况下,趋于平均地分摊在整个地址空间范围内
- 同一个 key 一定对应同一个哈希值,不同的 key 不一定对应到不同的哈希值,换句话说有可能有哈希值的冲突. (这和高中数学意义上的函数其实一样,一个 x 对应一个 y ,多个 x 有可能对应到同样的 y )

哈希值通常是一个固定的且无规律的整数. (哈希类算法还有 sha1 sha2 等 security 类的哈希. 这些哈希和这里所讲的哈希有一些区别,这些 security 类哈希往往生成比较慢,生成的哈希值是一个字符串而非整数,并且要求不能有哈希值的冲突.)

最常见的哈希函数就是转换成质数进制,然后对哈希表的大小进行取模.

```python
# key: string
def hash(key, HASH_SIZE):
    hashcode = 0
    HASH_PRIME = 31
    for char in key:
        hashcode *= HASH_PRIME
        hashcode += int(char)
        hashcode %= HASH_SIZE
    return hashcode
```

## 数组

数组是在内存里一段连续的地址空间,所以数组往往就是哈希表的实际存储介质. 一个 key 通过哈希函数算出一个哈希值, key 对应的 value 就直接存储在以这个哈希值为 index 的对应数组元素的位置.

# 冲突的解决办法

冲突 Collision ,是说两个不同的 key 经过哈希函数的计算后,得到了两个相同的值. 解决冲突的方法,主要有两种:

- 开散列法 Open Hashing 是指哈希表所基于的数组中,每个位置是一个 Linked List 的头结点. 这样冲突的`<key, value>`二元组,就都放在同一个链表中
- 闭散列法 Closed Hashing 是指在发生冲突的时候,后来的元素,往下一个位置去找空位.

业内通常使用开哈希.

# 重哈希 Rehashing

{% blockquote LintCode https://www.lintcode.com/problem/rehashing/description Rehashing %}
哈希表容量的大小在一开始是不确定的。如果哈希表存储的元素太多（如超过容量的十分之一），我们应该将哈希表容量扩大一倍，并将所有的哈希值重新安排。
{% endblockquote %}

## 实现

重哈希时由于`HASH_SIZE`变了,导致所有 key 的哈希值都会有较大变化,所以此时必须开辟新空间,并且重新计算**所有** key 的哈希值. 因此,重新哈希是一个很慢的过程.

## 重哈希条件

当哈希表里存储的是元素数量已经接近哈希表大小的时候,就需要进行重哈希. 这个比例可以是10%,也可以是90%. 具体多大取决于空间使用率和哈希表读写效率之间的 tradeoff .

- 如果过早重哈希,比如说已占用10%空间的时候就进行扩容重哈希,那么开辟的空间远大于当前数据量,空间使用较为浪费.
- 如果过晚重哈希,比如说已占用90%空间的时候才进行扩容重哈希,那么此时哈希表里可能已存在大量的哈希值冲突,其读写效率都已经受到较大影响.