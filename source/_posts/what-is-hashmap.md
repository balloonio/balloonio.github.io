---
title: What is Hashmap?
date: 2018-11-04 01:28:03
tags:
- algorithm
- hashmap
- data structure
---

This is a complete knowledge guide on hashmap.

<!-- more -->

# 综述

粗略的说,哈希表是一种读写均为常数级别时间复杂度的数据结构,支持`O(1)`时间添加删除和修改,数据之间无序. 为什么是粗略地说,因为严格来讲,其增删查改的时间复杂度与 key 的大小成正相关,这是由于哈希函数生成哈希值的时间复杂度为`O(size of key)`.  
哈希表的使用场景通常具有以下特点

- 快速增删查改
- 对有序性无要求

# 哈希表的实现

## 哈希函数

{% blockquote LintCode https://www.lintcode.com/problem/hash-function/description Hash Function %}
在数据结构中，哈希函数是用来将一个字符串（或任何其他类型）转化为小于哈希表大小且大于等于零的整数。一个好的哈希函数可以尽可能少地产生冲突。
{% endblockquote %}
&nbsp;
哈希函数的目的是作为一个映射,将key对应到一个地址空间上,通常的哈希函数具有如下特点.

- 快速生成哈希值,时间复杂度为`O(size of key)`
- 生成哈希值在一确定区间内,因为需要确切的地址空间范围来存储这些数据
- 生成的哈希值越随机越好,因为哈希值越随机就越与 key 无关,这就使得大量的数据可以不收 key 影响的情况下,趋于平均地分摊在整个地址空间范围内
- 同一个 key 一定对应同一个哈希值,不同的 key 不一定对应到不同的哈希值,换句话说有可能有哈希值的冲突. (这和高中数学意义上的函数其实一样,一个 x 对应一个 y ,多个 x 有可能对应到同样的 y )

哈希值通常是一个固定的且无规律的整数. (哈希类算法还有 sha1 sha2 等 security 类的哈希. 这些哈希和这里所讲的哈希有一些区别,这些 security 类哈希往往生成比较慢,生成的哈希值是一个字符串而非整数,并且要求不能有哈希值的冲突.)

最常见的哈希函数就是转换成质数进制,然后对哈希表的大小进行取模.

```python
# key: string
def hash(key, HASH_SIZE):
    hashcode = 0
    HASH_PRIME = 31
    for char in key:
        hashcode *= HASH_PRIME
        hashcode += int(char)
        hashcode %= HASH_SIZE
    return hashcode
```

## 数组

数组是在内存里一段连续的地址空间,所以数组往往就是哈希表的实际存储介质. 一个 key 通过哈希函数算出一个哈希值, key 对应的 value 就直接存储在以这个哈希值为 index 的对应数组元素的位置.

# 哈希冲突与解决办法

冲突 Collision ,是说两个不同的 key 经过哈希函数的计算后,得到了两个相同的值. 解决冲突的方法,主要有两种:

- 开哈希 Open Hashing 是指哈希表所基于的数组中,每个位置是一个 Linked List 的头结点. 这样冲突的`<key, value>`二元组,就都放在同一个链表中
- 闭哈希 Closed Hashing 是指在发生冲突的时候,后来的元素,往下一个位置去找空位.

业内通常使用开哈希. 开哈希 Open Hashing 又叫做单独链表 Separate Chaining , 闭哈希 Closed Hashing 又叫做开放地址 Open Addressing .

{% blockquote 灰杉树 https://www.zhihu.com/question/47258682/answer/134625235 哈希表针对冲突的两种方式优缺点是什么? %}

- 开放散列（open hashing）/ 拉链法（针对桶链结构）
    - 优点：
        - 对于记录总数频繁可变的情况，处理的比较好（也就是避免了动态调整的开销）
        - 由于记录存储在结点中，而结点是动态分配，不会造成内存的浪费，所以尤其适合那种记录本身尺寸（size）很大的情况，因为此时指针的开销可以忽略不计了
        - 删除记录时，比较方便，直接通过指针操作即可
    - 缺点：
        - 存储的记录是随机分布在内存中的，这样在查询记录时，相比结构紧凑的数据类型（比如数组），哈希表的跳转访问会带来额外的时间开销
        - 如果所有的 key-value 对是可以提前预知，并之后不会发生变化时（即不允许插入和删除），可以人为创建一个不会产生冲突的完美哈希函数（perfect hash function），此时封闭散列的性能将远高于开放散列
        - 由于使用指针，记录不容易进行序列化（serialize）操作
- 封闭散列（closed hashing）/ 开放定址法
    - 优点：
        - 记录更容易进行序列化（serialize）操作
        - 如果记录总数可以预知，可以创建完美哈希函数，此时处理数据的效率是非常高的
    - 缺点：
        - 存储记录的数目不能超过桶数组的长度，如果超过就需要扩容，而扩容会导致某次操作的时间成本飙升，这在实时或者交互式应用中可能会是一个严重的缺陷
        - 使用探测序列，有可能其计算的时间成本过高，导致哈希表的处理性能降低
        - 由于记录是存放在桶数组中的，而桶数组必然存在空槽，所以当记录本身尺寸（size）很大并且记录总数规模很大时，空槽占用的空间会导致明显的内存浪费
        - 删除记录时，比较麻烦。比如需要删除记录a，记录b是在a之后插入桶数组的，但是和记录a有冲突，是通过探测序列再次跳转找到的地址，所以如果直接删除a，a的位置变为空槽，而空槽是查询记录失败的终止条件，这样会导致记录b在a的位置重新插入数据前不可见，所以不能直接删除a，而是设置删除标记。这就需要额外的空间和操作。
{% endblockquote %}

# 重哈希 Rehashing

{% blockquote LintCode https://www.lintcode.com/problem/rehashing/description Rehashing %}
哈希表容量的大小在一开始是不确定的。如果哈希表存储的元素太多（如超过容量的十分之一），我们应该将哈希表容量扩大一倍，并将所有的哈希值重新安排。
{% endblockquote %}

## 重哈希的实现

重哈希时由于`HASH_SIZE`变了,导致所有 key 的哈希值都会有较大变化,所以此时必须开辟新空间,并且重新计算**所有** key 的哈希值. 因此,重新哈希是一个很慢的过程.

## 重哈希条件

当哈希表里存储的是元素数量已经接近哈希表大小的时候,就需要进行重哈希. 这个比例可以是10%,也可以是90%. 具体多大取决于空间使用率和哈希表读写效率之间的 tradeoff .

- 如果过早重哈希,比如说已占用10%空间的时候就进行扩容重哈希,那么开辟的空间远大于当前数据量,空间使用较为浪费.
- 如果过晚重哈希,比如说已占用90%空间的时候才进行扩容重哈希,那么此时哈希表里可能已存在大量的哈希值冲突,其读写效率都已经受到较大影响.